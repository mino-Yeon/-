<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript 기본 문법</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }

      body {
        font-family: sans-serif;
        background-color: #f8f8f8;
        color: #333;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        background-color: #333;
        color: white;
        padding: 16px 24px;
      }
      header h1 { font-size: 1.2rem; }

      .layout {
        display: flex;
        flex: 1;
        max-width: 1100px;
        width: 100%;
        margin: 0 auto;
        padding: 24px;
        gap: 24px;
      }

      nav.sidebar {
        width: 200px;
        flex-shrink: 0;
      }
      nav.sidebar .sidebar-inner {
        position: sticky;
        top: 24px;
        background-color: #fff;
        border-radius: 8px;
        padding: 16px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      }
      nav.sidebar h2 {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: #999;
        margin-bottom: 12px;
      }
      nav.sidebar ul { list-style: none; }
      nav.sidebar ul li { margin-bottom: 8px; }
      nav.sidebar ul li a {
        text-decoration: none;
        color: #555;
        font-size: 0.9rem;
      }
      nav.sidebar ul li a:hover { color: #ffa07a; }
      nav.sidebar ul li a.active { color: #ffa07a; font-weight: bold; }

      main { flex: 1; }

      .section {
        background-color: #fff;
        border-radius: 8px;
        padding: 28px;
        margin-bottom: 24px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      }

      .section h2 {
        font-size: 1.3rem;
        margin-bottom: 16px;
        padding-bottom: 10px;
        border-bottom: 2px solid bisque;
      }

      .section h3 {
        font-size: 1rem;
        margin: 20px 0 8px;
        color: #555;
      }

      .section p {
        font-size: 0.95rem;
        line-height: 1.7;
        color: #444;
        margin-bottom: 12px;
      }

      .section ul {
        padding-left: 20px;
        margin-bottom: 12px;
      }
      .section ul li {
        font-size: 0.95rem;
        line-height: 1.8;
        color: #444;
        list-style: disc;
      }

      pre {
        border-radius: 6px;
        overflow-x: auto;
        font-size: 0.9rem;
        line-height: 1.6;
        margin: 8px 0 16px;
      }
      pre code.hljs { border-radius: 6px; }
      .hljs-comment { color: #98c379 !important; }
      .hljs-string  { color: #e5c07b !important; }
      code { font-family: "Courier New", monospace; }

      p code, li code {
        background-color: #f0f0f0;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.88rem;
        color: #e06c75;
      }

      .tip {
        background-color: #fff8f0;
        border-left: 4px solid #ffa07a;
        padding: 12px 16px;
        border-radius: 0 6px 6px 0;
        margin: 12px 0;
        font-size: 0.9rem;
        color: #555;
        line-height: 1.6;
      }

      footer {
        background-color: #333;
        color: #aaa;
        text-align: center;
        padding: 16px;
        font-size: 0.85rem;
      }
    </style>
  </head>
  <body>

    <header>
      <h1>Javascript 기본 문법</h1>
    </header>

    <div class="layout">

      <nav class="sidebar">
        <div class="sidebar-inner">
          <h2>목차</h2>
          <ul>
            <li><a href="#comments">1. 주석</a></li>
            <li><a href="#variables">2. 변수 선언</a></li>
            <li><a href="#types">3. Primitive Type</a></li>
            <li><a href="#operators">4. 연산자</a></li>
            <li><a href="#hoisting">5. 호이스팅</a></li>
            <li><a href="#object">6. 객체</a></li>
            <li><a href="#function">7. 함수</a></li>
            <li><a href="#callback">8. 콜백 함수</a></li>
          </ul>
        </div>
      </nav>

      <main>

        <!-- 1. 주석 -->
        <section class="section" id="comments">
          <h2>1. 주석</h2>
          <p>코드에 설명을 추가하거나 특정 코드를 실행하지 않을 때 사용합니다.</p>

          <h3>라인 주석</h3>
          <pre><code>// 주석 내용</code></pre>

          <h3>블록 주석</h3>
          <pre><code>/*
  주석 내용
  여러 줄도 가능
*/</code></pre>
        </section>

        <!-- 2. 변수 선언 -->
        <section class="section" id="variables">
          <h2>2. 변수 선언</h2>
          <p>JavaScript에서 변수를 선언하는 방법은 세 가지입니다.</p>
          <ul>
            <li><code>var</code> — 함수 스코프, 재선언 가능, 호이스팅 O</li>
            <li><code>let</code> — 블록 스코프, 재선언 불가, 호이스팅 O (초기화 전 접근 불가)</li>
            <li><code>const</code> — 블록 스코프, 재선언·재할당 불가</li>
          </ul>
          <pre><code>var a = 1;
let b = 2;
const c = 3;</code></pre>
          <div class="tip">
            실무에서는 <code>let</code>과 <code>const</code>를 사용하고, <code>var</code>는 사용하지 않는 것을 권장합니다.
          </div>
        </section>

        <!-- 3. Primitive Type -->
        <section class="section" id="types">
          <h2>3. Primitive Type</h2>
          <p>JavaScript의 기본 자료형입니다.</p>
          <pre><code>const num  = 10;        // number
const str  = "hello";   // string
const bool = true;      // boolean
let empty;              // undefined — 선언만 되고 초기화한 적 없는 경우
const nothing = null;   // null — 의도적으로 비어있음을 나타내는 경우</code></pre>
          <div class="tip">
            <code>undefined</code>는 값이 할당된 적 없는 상태, <code>null</code>은 개발자가 의도적으로 비워둔 상태입니다.
          </div>
        </section>

        <!-- 4. 연산자 -->
        <section class="section" id="operators">
          <h2>4. 연산자</h2>
          <p>JavaScript에서 주의해야 할 비교 연산자입니다.</p>

          <h3>동등 연산자 vs 일치 연산자</h3>
          <p><code>==</code>은 타입이 달라도 자동으로 변환해서 비교하고, <code>===</code>은 타입까지 엄격하게 비교합니다.</p>
          <pre><code>console.log(1 == "1");   // true  — 타입 강제 변환 후 비교
console.log(1 === "1");  // false — 타입이 다르므로 false
console.log(1 === 1);    // true

console.log(null == undefined);  // true  — 느슨한 비교
console.log(null === undefined); // false — 엄격한 비교</code></pre>
          <div class="tip">
            실무에서는 예상치 못한 버그를 막기 위해 <code>===</code>을 사용하는 것을 권장합니다.
          </div>

          <h3>논리 연산자</h3>
          <pre><code>console.log(true && false); // false — AND: 둘 다 true여야 true
console.log(true || false); // true  — OR: 하나라도 true면 true
console.log(!true);         // false — NOT: 반전</code></pre>

          <h3>falsy / truthy</h3>
          <p>조건식에서 <code>false</code>로 평가되는 값들을 falsy라고 합니다.</p>
          <pre><code>// falsy 값: false, 0, "", null, undefined, NaN
// 이외의 값은 모두 truthy

console.log(Boolean(0));         // false
console.log(Boolean(""));        // false
console.log(Boolean(null));      // false
console.log(Boolean(undefined)); // false
console.log(Boolean("hello"));   // true
console.log(Boolean(1));         // true</code></pre>
        </section>

        <!-- 5. 호이스팅 -->
        <section class="section" id="hoisting">
          <h2>5. 호이스팅 (Hoisting)</h2>
          <p>변수나 함수 선언이 코드 실행 전에 맨 위로 끌어올려진 것처럼 동작하는 것을 말합니다.</p>

          <h3>케이스 1 — var 변수</h3>
          <p>선언은 끌어올려지지만 값은 아직 없으므로 <code>undefined</code>가 출력됩니다.</p>
          <pre><code>console.log(x); // undefined
var x = 10;</code></pre>

          <h3>케이스 2 — let / const 변수 (TDZ)</h3>
          <p>호이스팅은 되지만 선언 라인에 도달하기 전까지 접근할 수 없는 구간이 존재합니다. 이를 <strong>TDZ(Temporal Dead Zone)</strong>라고 합니다.</p>
          <pre><code>console.log(y); // ❌ ReferenceError: Cannot access 'y' before initialization
let y = 10;</code></pre>
          <div class="tip">
            <code>var</code>는 선언 전 접근 시 <code>undefined</code>를 반환하지만, <code>let</code>/<code>const</code>는 에러를 발생시킵니다. 이 덕분에 더 예측 가능한 코드를 작성할 수 있습니다.
          </div>

          <h3>케이스 3 — 함수 선언문</h3>
          <p>함수 전체가 끌어올려지므로 선언 전에 호출할 수 있습니다.</p>
          <pre><code>method1(); // "method1 실행"

function method1() {
  console.log("method1 실행");
}</code></pre>

          <h3>케이스 4 — 함수 표현식</h3>
          <p>변수 선언만 끌어올려지고 함수는 아직 할당되지 않아 에러가 발생합니다.</p>
          <pre><code>method2(); // ❌ TypeError: method2 is not a function

var method2 = function () {
  console.log("method2 실행");
};

method2(); // ✅ 할당 후에는 정상 호출 가능</code></pre>
        </section>

        <!-- 6. 객체 -->
        <section class="section" id="object">
          <h2>6. 객체 (Object)</h2>

          <h3>생성 방법</h3>
          <pre><code>// 1. 객체 리터럴
const obj1 = {};

// 2. Object 생성자 함수
const obj2 = new Object();

// 3. 생성자 함수
function Student(no, name, score) {
  this.no    = no;
  this.name  = name;
  this.score = score;
}
const stu = new Student(10, "학생1", "A");</code></pre>

          <h3>속성 참조</h3>
          <p>객체의 속성에 접근하는 방법은 두 가지입니다.</p>
          <ul>
            <li><code>object.key</code> — 점 표기법 (일반적인 경우)</li>
            <li><code>object["key"]</code> — 괄호 표기법 (특수문자 포함 키, 변수를 키로 쓸 때)</li>
          </ul>
          <pre><code>const obj = {
  key1: "value1",
  key2: "value2",
  "key3-special": "value3",
};

console.log(obj.key1);            // "value1"
console.log(obj["key2"]);         // "value2"
console.log(obj["key3-special"]); // "value3" — 특수문자 포함 키는 괄호 표기법만 가능</code></pre>

          <h3>변수를 키값으로 활용</h3>
          <pre><code>const input = "key1";

console.log(obj.input);  // undefined — "input"이라는 키를 찾음
console.log(obj[input]); // "value1" — 변수 input의 값(key1)으로 조회</code></pre>
        </section>

        <!-- 7. 함수 -->
        <section class="section" id="function">
          <h2>7. 함수 (Function)</h2>
          <p>JavaScript의 함수는 <strong>일급객체</strong>의 특징을 갖습니다. 변수에 저장하거나, 인자로 전달하거나, 반환값으로 사용할 수 있습니다.</p>

          <h3>함수 선언문</h3>
          <p>호이스팅이 적용되어 선언 순서와 관계없이 호출할 수 있습니다. 일반적인 함수 정의에 사용합니다.</p>
          <pre><code>function greet() {
  console.log("안녕하세요");
}</code></pre>

          <h3>함수 표현식</h3>
          <p>호이스팅이 적용되지 않습니다. 주로 콜백 함수나 일회용 함수에 사용합니다.</p>
          <pre><code>const greet = function () {
  console.log("안녕하세요");
};</code></pre>

          <h3>화살표 함수</h3>
          <p>함수 표현식을 더 간결하게 작성할 수 있는 문법입니다. 요즘 코드에서 가장 많이 사용됩니다.</p>
          <pre><code>// 기본 형태
const greet = () => {
  console.log("안녕하세요");
};

// 본문이 한 줄이면 중괄호와 return 생략 가능
const double = (n) => n * 2;
console.log(double(5)); // 10

// 매개변수가 하나면 괄호도 생략 가능
const double2 = n => n * 2;</code></pre>
          <div class="tip">
            화살표 함수는 자신만의 <code>this</code>를 갖지 않습니다. <code>this</code>가 필요한 생성자 함수나 메서드에는 일반 함수를 사용하세요.
          </div>

          <h3>매개변수와 전달인자</h3>
          <p>개수가 일치하지 않아도 에러 없이 호출됩니다.</p>
          <pre><code>function sum(a, b) {
  console.log(a, b);
}

sum(1);       // 1 undefined — 인자가 부족하면 undefined
sum(1, 2, 3); // 1 2 — 초과 인자는 무시</code></pre>

          <h3>일급객체 예시</h3>
          <pre><code>function test() {
  return greet; // 함수를 반환값으로 사용
}

const fn = test();
fn(); // "안녕하세요"</code></pre>
        </section>

        <!-- 8. 콜백 함수 -->
        <section class="section" id="callback">
          <h2>8. 콜백 함수 (Callback)</h2>
          <p>함수 호출 시 인자로 넘겨지는 함수입니다. 해당 함수가 실행되면서 내부적으로 호출됩니다.</p>
          <pre><code>console.log("시작");

setTimeout(function () {
  console.log("1초 후 실행되는 콜백 함수");
}, 1000);

console.log("끝");</code></pre>
          <div class="tip">
            출력 순서: "시작" → "끝" → (1초 후) "1초 후 실행되는 콜백 함수"<br />
            콜백 함수는 지금 바로 실행되지 않고, 나중에 호출된다는 것이 핵심입니다.
          </div>

          <h3>화살표 함수로 표현</h3>
          <p>콜백 함수는 화살표 함수로 간결하게 작성하는 경우가 많습니다.</p>
          <pre><code>setTimeout(() => {
  console.log("1초 후 실행");
}, 1000);

// 배열 메서드에서도 자주 사용
const nums = [1, 2, 3];
const doubled = nums.map(n => n * 2); // [2, 4, 6]</code></pre>
        </section>

      </main>
    </div>

    <footer>
      <p>&copy; 2025 YeonMall. All rights reserved.</p>
    </footer>

  </body>
</html>